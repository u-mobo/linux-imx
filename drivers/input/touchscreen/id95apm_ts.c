/*
 * touchscreen support for IDT ID95APM PMIC
 *
 * Copyright 2012 Pierluigi Passaro <info@phoenixsoftware.it>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License v2 as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

//#define DEBUG

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/platform_device.h>
#include <linux/input.h>
#include <linux/mfd/id95apm.h>

#undef ID95APM_TSC_SW_AVERAGE
#define ID95APM_TSC_SW_AVERAGE

#ifdef ID95APM_TSC_SW_AVERAGE

#define AVERAGE_SHIFT	3
#define AVERAGE_LEN	8	/* 1 << AVERAGE_SHIFT */
#define AVERAGE_MASK	7	/* AVERAGE_LEN - 1 */

#define AVERAGE_ARRAY_ADD(array, index, x, y, z) \
		array[AVERAGE_LEN].x -= array[index].x; \
		array[AVERAGE_LEN].y -= array[index].y; \
		array[AVERAGE_LEN].pressure -= array[index].pressure; \
		array[index].x = x; \
		array[index].y = y; \
		array[index].pressure = pressure; \
		array[AVERAGE_LEN].x += x; \
		array[AVERAGE_LEN].y += y; \
		array[AVERAGE_LEN].pressure += pressure

typedef struct point {
	unsigned x, y, pressure;
} point_t;

point_t average_array[AVERAGE_LEN + 1];
static short average_samples = 0;
static short average_index = 0;

#endif /* ID95APM_TSC_SW_AVERAGE */

static int swap_xy = 0;
static int invert_x = 0;
static int invert_y = 1;

#define ID95APM_AUTO_CALIBRATION
#ifdef ID95APM_AUTO_CALIBRATION
static void do_calibration(int *xorig, int *yorig)
{
	static unsigned xmin = 0x100;
	static unsigned xmax = 0xeff;
	static unsigned ymin = 0x100;
	static unsigned ymax = 0xeff;
	static unsigned xdiff = 0xe00;
	static unsigned ydiff = 0xe00;

	if (*xorig < xmin) {
		xmin = *xorig;
		xdiff = xmax - xmin +1; 
	}
	if (*xorig > xmax) {
		xmax = *xorig;
		xdiff = xmax - xmin +1; 
	}
	if (*yorig < ymin) {
		ymin = *yorig;
		ydiff = ymax - ymin +1; 
	}
	if (*yorig > ymax) {
		ymax = *yorig;
		ydiff = ymax - ymin +1; 
	}

	*xorig = ((*xorig - xmin) << 12) / xdiff;
	*yorig = ((*yorig - ymin) << 12) / ydiff;
}
#else
/**
 * calibration array refers to
 * (delta_x[0], delta_x[1], delta_x[2], delta_y[0], delta_y[1], delta_y[2], delta).
 * Which generated by calibration service.
 * In this driver when we got touch pointer (x', y') from PMIC ADC,
 * we calculate the display pointer (x,y) by:
 * x = (delta_x[0] * x' + delta_x[1] * y' + delta_x[2]) / delta;
 * y = (delta_y[0] * x' + delta_y[1] * y' + delta_y[2]) / delta;
 */
static int calibration[7] = {1, 0, 0, 0, 1, 0, 1};
module_param_array(calibration, int, NULL, S_IRUGO | S_IWUSR);

static void do_calibration(int *x_orig, int *y_orig)
{
	int x, y;
	if (calibration[6] == 0)
		return;
	x = calibration[0] * (*x_orig) +
		calibration[1] * (*y_orig) +
		calibration[2];
	x /= calibration[6];
	if (x < 0)
		x = 0;
	y = calibration[3] * (*x_orig) +
		calibration[4] * (*y_orig) +
		calibration[5];
	y /= calibration[6];
	if (y < 0)
		y = 0;

	*x_orig = x;
	*y_orig = y;
}
#endif

static void id95apm_tsc_work_handler(struct work_struct *work)
{
	struct id95apm_tsc *tsc = container_of(work, struct id95apm_tsc, work.work);
	struct id95apm *id95apm = input_get_drvdata(tsc->input);

	if (id95apm->tsc.button_pressed) {
		id95apm->tsc.button_pressed = 0;
		input_report_abs(id95apm->tsc.input, ABS_PRESSURE, 0);
		input_report_key(id95apm->tsc.input, BTN_TOUCH, 0);
		input_sync(id95apm->tsc.input);
		dev_dbg(id95apm->dev, "pen delayed release\n");
	}
#ifdef ID95APM_TSC_SW_AVERAGE
	if (average_samples)
		average_samples = 0;
#endif /* ID95APM_TSC_SW_AVERAGE */
}

static void id95apm_tsc_irq_handler(struct id95apm *id95apm, int irq, void *data)
{
	unsigned x, y, pen_down;
	unsigned z1, z2, pressure = 0;

	cancel_delayed_work_sync(&id95apm->tsc.work);

	pen_down = id95apm_reg_read(id95apm, ID95APM_TSC_MEASURE_STAT) & 0x01;
	x = id95apm_reg16_read(id95apm, ID95APM_TSC_X_CH1_RES);
	y = id95apm_reg16_read(id95apm, ID95APM_TSC_Y_CH2_RES);
	z1 = id95apm_reg16_read(id95apm, ID95APM_TSC_CH3_RES);
	z2 = id95apm_reg16_read(id95apm, ID95APM_TSC_CH4_RES);

	if (pen_down) {
		if ((x != 0) && (z1 != z2)) {
			pressure = (z1 << 20) / (x * (z2 - z1));
			dev_dbg(id95apm->dev, "z1:%d, z2:%d, pressure:%d\n", z1, z2, pressure);
		}
		if (swap_xy) {
			unsigned h = x;
			x = y;
			y = h;
		}
		if (invert_x)
			x = (~x) & 0xfff;
		if (invert_y)
			y = (~y) & 0xfff;
		dev_dbg(id95apm->dev, "pen down at [%d, %d]\n", x, y);
#ifdef ID95APM_TSC_SW_AVERAGE
		if (average_samples == 0) {
			average_index = 0;
			memset(average_array, 0, sizeof(average_array));
		}
		AVERAGE_ARRAY_ADD(average_array, average_index, x, y, pressure);
		average_index++;
		average_index &= AVERAGE_MASK;
		if (average_samples < AVERAGE_MASK) {
			average_samples++;
			schedule_delayed_work(&id95apm->tsc.work, HZ / 20);
			id95apm_clrset_bits(id95apm, ID95APM_TSC_PENDING_IRQ, 0x01, 0x01);
			return;
		} else {
			x = average_array[AVERAGE_LEN].x >> AVERAGE_SHIFT;
			y = average_array[AVERAGE_LEN].y >> AVERAGE_SHIFT;
			pressure = average_array[AVERAGE_LEN].pressure >> AVERAGE_SHIFT;
		}
#endif /* ID95APM_TSC_SW_AVERAGE */
		do_calibration(&x, &y);
		input_report_abs(id95apm->tsc.input, ABS_X, x);
		input_report_abs(id95apm->tsc.input, ABS_Y, y);
		input_report_abs(id95apm->tsc.input, ABS_PRESSURE, pressure);
		if (!id95apm->tsc.button_pressed) {
			id95apm->tsc.button_pressed = 1;
			input_report_key(id95apm->tsc.input, BTN_TOUCH, 1);
		}
		input_sync(id95apm->tsc.input);
		schedule_delayed_work(&id95apm->tsc.work, HZ / 20);
	} else if (id95apm->tsc.button_pressed) {
#ifdef ID95APM_TSC_SW_AVERAGE
		average_samples = 0;
#endif /* ID95APM_TSC_SW_AVERAGE */
		id95apm->tsc.button_pressed = 0;
		input_report_abs(id95apm->tsc.input, ABS_PRESSURE, 0);
		input_report_key(id95apm->tsc.input, BTN_TOUCH, 0);
		input_sync(id95apm->tsc.input);
		dev_dbg(id95apm->dev, "pen release\n");
	}

	id95apm_clrset_bits(id95apm, ID95APM_TSC_PENDING_IRQ, 0x01, 0x01);
}

static int id95apm_tsc_open(struct input_dev *dev) {
	struct id95apm *id95apm = input_get_drvdata(dev);

	/* Enable TSC/measuring subsystem */
	id95apm_reg_write(id95apm, ID95APM_PCON_TSC_CTRL, 0x01);

	/* Select TSC (touch screen) mode instead ADC mode */
	id95apm_reg_write(id95apm, ID95APM_TSC_MEASURE_CONF, 0x05);

	/*
	 * Configure pin multiplexing:
	 * Select ADC0...ADC3 as ADC instead of GPIO6...9
	 */
	id95apm_clrset_bits16(id95apm, ID95APM_PCON_GPIO_OFF, 0x03c0, 0x03c0);

	/* Enable touch interrupt */
	id95apm_clrset_bits(id95apm, ID95APM_TSC_MEASURE_EN, 0x01, 0x01);

	return 0;
}

static void id95apm_tsc_close(struct input_dev *dev) {
	struct id95apm *id95apm = input_get_drvdata(dev);

	/* Disable touch interrupt */
	id95apm_clrset_bits(id95apm, ID95APM_TSC_MEASURE_EN, 0x01, 0x00);

	/* Disable TSC/measuring subsystem */
	id95apm_reg_write(id95apm, ID95APM_PCON_TSC_CTRL, 0x00);
}

static int id95apm_tsc_probe(struct platform_device *pdev)
{
	struct id95apm *id95apm = platform_get_drvdata(pdev);
	int ret;

	id95apm->tsc.input = input_allocate_device();
	if (!id95apm->tsc.input) {
		dev_err(&pdev->dev, "allocate input device failed\n");
		ret = -ENOMEM;
		goto err_allocate;
	}

	id95apm->tsc.input->name = ID95APM_TSC_NAME;
	id95apm->tsc.input->dev.parent = &pdev->dev;

	__set_bit(EV_ABS, id95apm->tsc.input->evbit);
	__set_bit(EV_KEY, id95apm->tsc.input->evbit);
	__set_bit(ABS_X, id95apm->tsc.input->absbit);
	__set_bit(ABS_Y, id95apm->tsc.input->absbit);
	__set_bit(ABS_PRESSURE, id95apm->tsc.input->absbit);
	__set_bit(BTN_TOUCH, id95apm->tsc.input->keybit);

	input_set_abs_params(id95apm->tsc.input, ABS_X, 0, 0xfff, 0, 0);
	input_set_abs_params(id95apm->tsc.input, ABS_Y, 0, 0xfff, 0, 0);
	input_set_abs_params(id95apm->tsc.input, ABS_PRESSURE, 0, 0xfff, 0, 0);

	id95apm->tsc.input->open = id95apm_tsc_open;
	id95apm->tsc.input->close = id95apm_tsc_close;

	input_set_drvdata(id95apm->tsc.input, id95apm);

	ret = input_register_device(id95apm->tsc.input);
	if (ret) {
		dev_err(&pdev->dev, "register input device failed with %d\n", ret);
		goto err_register;
	}

	id95apm->tsc.button_pressed = 0;

#ifdef ID95APM_TSC_SW_AVERAGE
	/* Disable touch average */
	id95apm_clrset_bits(id95apm, ID95APM_TSC_AVERAGE_TIMER, 0x38, 0x00);
#else
	/* Enable touch average */
	id95apm_clrset_bits(id95apm, ID95APM_TSC_AVERAGE_TIMER, 0x38, 0x20);
#endif /* ID95APM_TSC_SW_AVERAGE */

	/* Configure touch: 8.19ms pendown debounce, 8.19ms penup debounce,
	 * z1 and z2 measure, 96us acquisition delay */
	id95apm_reg_write(id95apm, ID95APM_TSC_CONFIG, 0xfe);

	INIT_DELAYED_WORK(&id95apm->tsc.work, id95apm_tsc_work_handler);

	/* Register touch interrupt */
	id95apm_register_irq(id95apm, ID95APM_IRQ_TOUCH, id95apm_tsc_irq_handler, NULL);

	dev_info(&pdev->dev, "id95apm tsc initialized\n");

	return 0;

err_register:
	input_free_device(id95apm->tsc.input);
err_allocate:
	return ret;
}

static int id95apm_tsc_remove(struct platform_device *pdev)
{
	struct id95apm *id95apm = platform_get_drvdata(pdev);

	/* Free touch interrupt */
	id95apm_free_irq(id95apm, ID95APM_IRQ_TOUCH);

	input_unregister_device(id95apm->tsc.input);
	input_free_device(id95apm->tsc.input);

	return 0;
}

static struct platform_driver id95apm_tsc_driver = {
	.probe = id95apm_tsc_probe,
	.remove = id95apm_tsc_remove,
	.driver = {
		.name = ID95APM_TSC_NAME,
		.owner = THIS_MODULE,
	},
};

static int __init id95apm_tsc_init(void)
{
	return platform_driver_register(&id95apm_tsc_driver);
}
module_init(id95apm_tsc_init);

static void __exit id95apm_tsc_exit(void)
{
	platform_driver_unregister(&id95apm_tsc_driver);
}
module_exit(id95apm_tsc_exit);

MODULE_AUTHOR("Pierluigi Passaro <info@phoenixsoftware.it>");
MODULE_DESCRIPTION("ID95APM Touch Screen Controller");
MODULE_LICENSE("GPL");
